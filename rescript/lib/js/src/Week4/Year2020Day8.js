// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Belt_Int = require("rescript/lib/js/belt_Int.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");

var input = Fs.readFileSync("input/Week4/Year2020Day8.txt", "utf8");

function parser(input$p) {
  return Belt_Array.keepMap(input$p.split("\n"), (function (i) {
                var match = i.split(" ");
                if (match.length !== 2) {
                  return ;
                }
                var instruction = match[0];
                var value = match[1];
                var value$p = Belt_Int.fromString(value);
                if (value$p === undefined) {
                  return ;
                }
                switch (instruction) {
                  case "acc" :
                      return [
                              /* Acc */1,
                              value$p,
                              false
                            ];
                  case "jmp" :
                      return [
                              /* Jmp */2,
                              value$p,
                              false
                            ];
                  case "nop" :
                      return [
                              /* Nop */0,
                              value$p,
                              false
                            ];
                  default:
                    return ;
                }
              }));
}

function update(instructions, nextIndex) {
  var match = Belt_Array.get(instructions, nextIndex);
  if (match !== undefined) {
    return Belt_Array.concatMany([
                Belt_Array.slice(instructions, 0, nextIndex),
                [[
                    match[0],
                    match[1],
                    true
                  ]],
                Belt_Array.sliceToEnd(instructions, nextIndex + 1 | 0)
              ]);
  } else {
    return instructions;
  }
}

function next(param) {
  var instructions = param.instructions;
  var nextIndex = param.nextIndex;
  var accumulator = param.accumulator;
  var match = Belt_Array.get(instructions, nextIndex);
  if (match === undefined) {
    return {
            accumulator: accumulator,
            nextIndex: nextIndex,
            instructions: instructions
          };
  }
  if (match[2]) {
    return {
            accumulator: accumulator,
            nextIndex: -1,
            instructions: instructions
          };
  }
  switch (match[0]) {
    case /* Nop */0 :
        return {
                accumulator: accumulator,
                nextIndex: nextIndex + 1 | 0,
                instructions: update(instructions, nextIndex)
              };
    case /* Acc */1 :
        return {
                accumulator: accumulator + match[1] | 0,
                nextIndex: nextIndex + 1 | 0,
                instructions: update(instructions, nextIndex)
              };
    case /* Jmp */2 :
        return {
                accumulator: accumulator,
                nextIndex: nextIndex + match[1] | 0,
                instructions: update(instructions, nextIndex)
              };
    
  }
}

var inst = parser(input);

var state = {
  accumulator: 0,
  nextIndex: 0,
  instructions: inst
};

function findInfinLoop(_state) {
  while(true) {
    var state = _state;
    var state$p = next(state);
    if (state$p.nextIndex === -1 || state$p.nextIndex >= state$p.instructions.length) {
      return state$p;
    }
    _state = state$p;
    continue ;
  };
}

var current = findInfinLoop(state);

console.log(current.accumulator);

var instructions = parser(input);

function change(_nextIndex, instructions) {
  while(true) {
    var nextIndex = _nextIndex;
    var match = Belt_Array.get(instructions, nextIndex);
    if (match === undefined) {
      return [
              nextIndex + 1 | 0,
              instructions
            ];
    }
    switch (match[0]) {
      case /* Nop */0 :
          return [
                  nextIndex + 1 | 0,
                  Belt_Array.concatMany([
                        Belt_Array.slice(instructions, 0, nextIndex),
                        [[
                            /* Jmp */2,
                            match[1],
                            match[2]
                          ]],
                        Belt_Array.sliceToEnd(instructions, nextIndex + 1 | 0)
                      ])
                ];
      case /* Acc */1 :
          _nextIndex = nextIndex + 1 | 0;
          continue ;
      case /* Jmp */2 :
          return [
                  nextIndex + 1 | 0,
                  Belt_Array.concatMany([
                        Belt_Array.slice(instructions, 0, nextIndex),
                        [[
                            /* Nop */0,
                            match[1],
                            match[2]
                          ]],
                        Belt_Array.sliceToEnd(instructions, nextIndex + 1 | 0)
                      ])
                ];
      
    }
  };
}

function hasLoop(instructions) {
  var state = {
    accumulator: 0,
    nextIndex: 0,
    instructions: instructions
  };
  var finalState = findInfinLoop(state);
  if (finalState.nextIndex === -1) {
    return /* Loop */0;
  } else {
    return /* NoLoop */{
            _0: finalState.accumulator
          };
  }
}

function handleLoop(_nextIndex, instructions) {
  while(true) {
    var nextIndex = _nextIndex;
    var match = change(nextIndex, instructions);
    var acc$p = hasLoop(match[1]);
    if (acc$p) {
      return acc$p._0;
    }
    _nextIndex = match[0];
    continue ;
  };
}

console.log(handleLoop(0, instructions));

exports.input = input;
exports.parser = parser;
exports.update = update;
exports.next = next;
exports.inst = inst;
exports.state = state;
exports.findInfinLoop = findInfinLoop;
exports.current = current;
exports.instructions = instructions;
exports.change = change;
exports.hasLoop = hasLoop;
exports.handleLoop = handleLoop;
/* input Not a pure module */
